<!doctype html> 
<html lang="en"> 
<head> 
	<meta charset="UTF-8" />
	<title>Phaser - Factibilidad</title>
	<script src="//cdn.jsdelivr.net/npm/phaser@3.22.0/dist/phaser.js"></script>
	<script src='https://cdn.jsdelivr.net/npm/sockjs-client@1.1/dist/sockjs.min.js'></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">
function JugadorServer(nombre, x, y, angle)
{
	this.nombre = nombre;
	this.x = x;
	this.y = y;
	this.angle = angle;
}
var config = {
    type: Phaser.AUTO,
    width: 800,
    height: 600,
    physics: {
        default: 'arcade',
        arcade: {
        	debug: true,
            gravity: {
            	fps: 60,
                y: 0
            }
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

//definiciones de phaser
var game = new Phaser.Game(config);
var cursors;
var bote1, patrullero1, jugador;

//definicion de cual comando
var mensaje = "{ \"accion\" : \"tiempo\", \"tiempoRestante\" : \" " + 0 + " \"}";
var textoTiempo;
var time;
var texto;
var jugadorRemoto;

var zoomOut, zoomIn;
var self;
var cursor;
var dict = {};

function preload() {
	
    //carga las imagenes al juegoç
    this.load.image('plataforma', 'assets/sky_big.png');
    this.load.image('bote1', 'assets/bote1_h.png');
    this.load.image('patrullero1', 'assets/patrullero1_h.png');

}

function create() {
	self = this;
	 //El "mundo" es de 4000 x 3000
	cursor = this.add.image(0, 0, 'cursor').setVisible(false);
	this.physics.world.setBounds(0, 0, 4000, 3000);
    this.cameras.main.setBounds(0, 0, 4000, 3000).setName('main');
	
    this.add.image(2000, 1500, 'plataforma');
    
    bote1 = this.physics.add.sprite(1600, 1600, 'bote1').setInteractive();
    
    bote1.on('pointerdown', function(game){
        jugador = bote1;
        jugador.nombre = "bote1";
	});
	dict['bote1'] = bote1;
	bote1.setDamping(true);
	bote1.setDrag(0.99);
	bote1.setMaxVelocity(200);
	bote1.setCollideWorldBounds(true);
	bote1.movedByClick = 0;
	bote1.setAngle(270);
	
    patrullero1 = this.physics.add.sprite(1500, 1700, 'patrullero1').setInteractive();
   
    patrullero1.on('pointerdown', function(){
        jugador = patrullero1;
        jugador.nombre = "patrullero1";
	});
    dict['patrullero1'] = patrullero1;
    patrullero1.setDamping(true);
    patrullero1.setDrag(0.99);
    patrullero1.setMaxVelocity(200);
	patrullero1.setCollideWorldBounds(true);
	patrullero1.movedByClick = 0;
	patrullero1.setAngle(270);
	
    websocket = new WebSocket('ws://localhost:8080/taller3/juego/');
    websocketAcciones = new WebSocket('ws://localhost:8080/taller3/acciones/');
    cursors = this.input.keyboard.createCursorKeys();

    texto = this.add.text(0, 0, "Controla la patrulla:" , { font: "14px Arial", fill: "#ff0044"});
    textoTiempo = this.add.text(32, 32, 'Tiempo restante de partida: ' + time);
    
    zoomOut = this.input.keyboard.addKey('O'); 
    zoomIn = this.input.keyboard.addKey('I');  
	
	this.input.on('pointerdown', function(pointer){
	    	//destination = this.physics.add.image(pointer.worldX, pointer.worldY, 'transparente');
	    	var target = new Phaser.Math.Vector2();
	    	target.x = pointer.worldX;
        	target.y = pointer.worldY;
	    	var angleToPointer = Phaser.Math.Angle.Between(dict[jugador.nombre].x, dict[jugador.nombre].y, target.x, target.y);
			var angleDelta = Phaser.Math.Angle.Wrap(angleToPointer - dict[jugador.nombre].rotation);
			dict[jugador.nombre].rotation = angleToPointer;
			dict[jugador.nombre].setAngularVelocity(0);
			dict[jugador.nombre].target = target;
			dict[jugador.nombre].movedByClick = 1;
			dict[jugador.nombre].setDrag(1);
	    	this.physics.moveToObject(jugador, jugador.target, 200);
    }, this);
	
	this.physics.add.collider(
			patrullero1, 
			bote1,
	        function (_patrullero1, _bote1)
	        {
				_patrullero1.setDrag(0.99);
				_bote1.setDrag(0.99);
	        });

}

function enviarJSON(objeto) {
    let json = JSON.stringify(objeto);
    websocket.send(json);
}

function enviarJSONAcciones(objeto) {
    let json = JSON.stringify(objeto);
    websocketAcciones.send(json);
}


function keysPressed(self)
{
	if (Phaser.Input.Keyboard.JustDown(zoomOut))
    {
		self.cameras.main.setZoom(0.2);
    }
	else{
		if (Phaser.Input.Keyboard.JustDown(zoomIn))
	    {
			self.cameras.main.setZoom(1);
	    }
	}
}

function stopBoatMovement()
{
	if(jugador != null && dict != null)
	{
		for (var key in dict) 
		{
		    if (dict.hasOwnProperty(key)) 
		    {        
		    	if(dict[key].target != null)
		    	{
		    		var distance = Phaser.Math.Distance.Between(dict[key].x, dict[key].y, dict[key].target.x, dict[key].target.y);
					if (dict[key].body.speed > 0)
				    {
				       if (distance < 4)
				       {
				    	   dict[key].body.reset(dict[key].target.x, dict[key].target.y);
				    	   dict[key].movedByClick = 0;
				    	   dict[key].setDrag(0.99);
				       }
				    }
		    	}	
		    }
		}
	}
}
function update() {
	stopBoatMovement();
	
	keysPressed(self);
	websocket.onmessage = function(event) {
	    if(event.data != null)
	    {
	    	//defino el jugador
	    	if(typeof jugador === 'undefined')
	    	{
	    		let nombre = JSON.parse(event.data);
	    		
	    		if(nombre == 'bote1')
	    		{
	    			jugador = bote1;
	    			jugador.nombre = nombre;
	    			bote1.target = new Phaser.Math.Vector2();
	    		}
	    		else 
	    		{
	    			if(nombre == 'patrullero1')
	    			{
	    				jugador = patrullero1;
	    				jugador.nombre = nombre;
	    				patrullero1.target = new Phaser.Math.Vector2();
	    			}
	    			
	    		}
	    	}
	    	else
	    	{
	  	    	let jugadorServer = JSON.parse(event.data);
	  	    	if(jugador == bote1 && jugadorServer.nombre != 'bote1'){
	  	    		jugadorRemoto = patrullero1;
	  	    	}
	  	    	else{
	  	    		if(jugador == patrullero1 && jugadorServer.nombre != 'patrullero1'){
		  	    		jugadorRemoto = bote1;
	  	    		}
	  	    	}
	  	    //actualizo rival
	  	    	if(jugadorRemoto != null && !(typeof jugadorRemoto === 'undefined') &&  jugadorServer.nombre != jugador.nombre)
	  	    	{
	  	    		jugadorRemoto.x = jugadorServer.x;
		  	    	jugadorRemoto.y = jugadorServer.y;
		  	    	jugadorRemoto.angle = jugadorServer.angle;
	  	    	}
	    	}
	    }
  };
//actualiza las imagenes cuando te vas moviendo
   
    
	if (jugador != null && !(typeof jugador === 'undefined'))
    {
		texto.setText("Controla la patrulla:" + jugador.nombre);
		if (cursors.up.isDown)
	    {
			jugador = dict[jugador.nombre];
			jugador.target = new Phaser.Math.Vector2();
	    	this.physics.velocityFromRotation(jugador.rotation, 200, jugador.body.acceleration);
	    	jugador.movedByClick = 0;
	    	jugador.setDrag(0.99);
	    }
	    else
    	{
	    	if(jugador.movedByClick == 0)
	    	{	
	    		jugador.setAcceleration(0);
	    	}
    	}
		if (cursors.left.isDown)
	    {
			jugador.setAngularVelocity(-300);
	    }
	    else if (cursors.right.isDown)
	    {
	    	jugador.setAngularVelocity(300);
	    }
	    else
	    {
	    	jugador.setAngularVelocity(0);
	    }
        let jugadorServer = new JugadorServer(jugador.nombre, jugador.x, jugador.y, jugador.angle);
        enviarJSON(jugadorServer);
        
   		// Centro la camara en el jugador
        // -400 porque el ancho es 800
        this.cameras.main.scrollX = jugador.x - 400;
        this.cameras.main.scrollY = jugador.y - 300;
        
        //  Como esta camara es de 400px de ancho, centro resto 200
//         this.minimap.scrollX = Phaser.Math.Clamp(jugador.x - 200, 800, 2000);
    }
    
// LOGICA PARA MANEJO DE ACCIONES
	
	websocketAcciones.onmessage = function(event) {
	    if(event.data != null) {
			
	    	let mensaje = JSON.parse(event.data);
	    		
	    		switch (mensaje.accion){
	    			
	    			case 'tiempo':
	    				time = mensaje.tiempoRestante;
	    				// Actualizacion del timer
    					textoTiempo.setText('Tiempo restante de partida: ' + time);
	    				break;
	    				
	    			case 'estadoJuego':
	    				if(mensaje.estadoActual == 'FINALIZADO'){
	    					//Logica de finalizacion del juego
	    					alert("Se ha terminado el tiempo, el juego finalizó.");
	    				}
	    				break;
	    				
	    			case 'disparo':
	    				break;
	    		}
	    }
	    		
  	};
	
	
	

}

</script>

</body>
</html>